% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FuncPairBatchFeature.R
\name{batchFindSignificantFeatures}
\alias{batchFindSignificantFeatures}
\title{Batch analysis to find significant features associated with a reference feature using DromaSet objects}
\usage{
batchFindSignificantFeatures(
  dromaset_object,
  feature1_type,
  feature1_name,
  feature2_type,
  feature2_name = NULL,
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE,
  cores = 1,
  progress_callback = NULL,
  test_top_n = NULL,
  verbose = FALSE
)
}
\arguments{
\item{dromaset_object}{Either a DromaSet or MultiDromaSet object}

\item{feature1_type}{Type of the reference feature (e.g., "drug", "mRNA")}

\item{feature1_name}{Name of the reference feature}

\item{feature2_type}{Type of features to test against (e.g., "mRNA", "mutation_gene")}

\item{feature2_name}{Optional vector of specific feature names to test (default: NULL for all features)}

\item{data_type}{Filter by data type ("all", "CellLine", "PDO", "PDC", "PDX")}

\item{tumor_type}{Filter by tumor type ("all" or specific tumor types)}

\item{overlap_only}{For MultiDromaSet, whether to use only overlapping samples (default: FALSE)}

\item{cores}{Number of CPU cores to use for parallel processing}

\item{progress_callback}{Optional callback function for progress updates}

\item{test_top_n}{Integer, number of top features to test (default: NULL for all features)}

\item{verbose}{Logical, whether to display detailed messages from internal functions (default: FALSE)}
}
\value{
Data frame with meta-analysis results (p_value, effect_size, n_datasets, name, q_value). NA values are replaced: p_value -> 1, effect_size -> 0. q_value is calculated using Benjamini-Hochberg method
}
\description{
Performs batch analysis to identify features significantly associated with a reference feature using DromaSet or MultiDromaSet objects
}
\section{Execution Flow}{

The function follows this high-level workflow:
1. Input validation and parameter setup
2. Feature type determination (continuous vs discrete)
3. Load and validate reference feature (feature1) data
4. Get list of features to test (feature2) - uses listDROMAFeatures() for efficient database queries
5. Parallel/sequential processing of feature pairs with on-demand data loading
6. Statistical testing based on feature types
7. Result aggregation and reporting
}

\section{Optimizations}{

This function implements several optimizations for better performance and memory usage:
\itemize{
  \item{Feature List Retrieval: Uses listDROMAFeatures() from DROMA.Set package to efficiently 
        query available features directly from the database without loading full data matrices}
  \item{On-Demand Data Loading: Loads feature2 data only when needed for each feature pair,
        reducing memory footprint especially for large datasets with thousands of features}
  \item{Automatic Fallback: If database queries fail, automatically falls back to traditional
        data loading methods for compatibility}
}
}

\examples{
\dontrun{
# Using DromaSet
gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")
results <- batchFindSignificantFeatures(gCSI, "drug", "Paclitaxel", "mRNA")

# Using MultiDromaSet
multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "path/to/droma.sqlite")
results <- batchFindSignificantFeatures(multi_set, "drug", "Paclitaxel", "mRNA",
                                  feature2_name = c("TP53", "EGFR"))

# Test only top 50 features for debugging
results <- batchFindSignificantFeatures(multi_set, "drug", "Paclitaxel", "mRNA", test_top_n = 50)
}
}
